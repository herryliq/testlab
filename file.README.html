<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.7.3
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><p><a href="http://badge.fury.io/rb/testlab"><img src="https://badge.fury.io/rb/testlab.png" alt="Gem Version"></a>
<a href="https://gemnasium.com/lookout/testlab"><img src="https://gemnasium.com/lookout/testlab.png" alt="Dependency Status"></a>
<a href="http://travis-ci.org/lookout/testlab"><img src="https://secure.travis-ci.org/lookout/testlab.png" alt="Build Status"></a>
<a href="https://coveralls.io/r/lookout/testlab"><img src="https://coveralls.io/repos/lookout/testlab/badge.png?branch=master" alt="Coverage Status"></a>
<a href="https://codeclimate.com/github/lookout/testlab"><img src="https://codeclimate.com/github/lookout/testlab.png" alt="Code Climate"></a></p>

<h1>What is TestLab?</h1>

<p>Simply put; a toolkit for building virtual computer labs.</p>

<p>TestLab lets you iterate virtual infrastructure quickly.  Using a <code>Labfile</code> you can define how you want your virtual infrastructure laid out.  You can define multiple network segments and containers (i.e. boxen).  TestLab will then build and demolish this virtual infrastructure as you have dictated in the <code>Labfile</code>.</p>

<p>TestLab also allows you to template objects, meaning less congestion in your <code>Labfile</code>.</p>

<p>TestLab can also import and export containers, making it easy to share them.  TestLab supports the latest LXC versions, allowing for ephemeral cloning operations, furthering your ability to iterate quickly.  TestLab can be used for many other applications, including infrastructure unit and integration testing, allowing for vastly more complex configurations and more effective resource sharing than traditional VM solutions.</p>

<p>TestLab can be run via the command-line or can be interfaced with directly via Ruby code.</p>

<h1>Troubleshooting</h1>

<p>To get debug level output run TestLab with a <code>-v</code> flag like this:</p>

<pre class="code ruby"><code class="ruby">tl -v container build -n chef-client
</code></pre>

<p>or you can control this by setting the environment variable <code>VERBOSE</code> to <code>1</code>:</p>

<pre class="code ruby"><code class="ruby">VERBOSE=1 tl container build -n chef-client
</code></pre>

<p>Alternately you can silence the output with the <code>-q</code> flag or by setting the environment variable <code>QUIET</code> to <code>1</code>.</p>

<h1>Reporting Issues and Bugs</h1>

<p>If you are having issues, please generate a bug report and reference in an issue on GitHub.</p>

<p>To generate a bug report run the following command:</p>

<pre class="code ruby"><code class="ruby">$ tl -q bugreport
Your bug report is located at &quot;/tmp/testlab-bug-report.1391307431&quot;.
</code></pre>

<h1>Getting Help and General Usage</h1>

<p>You can get help a few ways:</p>

<ul>
<li>Use the help command to get details on sets of commands or specific commands.</li>
<li>On Freenode IRC, in #jovelabs</li>
</ul>

<p>TestLab uses the GLI RubyGem, which gives us a command line pattern similar to that of Git.  Help for commands is not far away, for example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_help'>help</span>
<span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_help'>help</span> <span class='id identifier rubyid_node'>node</span> <span class='id identifier rubyid_recycle'>recycle</span>
<span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_help'>help</span> <span class='id identifier rubyid_network'>network</span> <span class='id identifier rubyid_build'>build</span>
<span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_help'>help</span> <span class='id identifier rubyid_container'>container</span> <span class='id identifier rubyid_import'>import</span>
<span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_help'>help</span> <span class='id identifier rubyid_container'>container</span> <span class='id identifier rubyid_demolish'>demolish</span>
</code></pre>

<p>You can also shorten commands; for example <code>tl container recycle</code> can also be written as <code>tl con rec</code>.</p>

<p>When supplying container names you actually have three options.  When you do not supply a container name, it is inferred that you want to run the action against all containers.  Alternately you can supply a single container name or a comma delimited list of container names.  For example:</p>

<pre class="code ruby"><code class="ruby">tl container build                             # build all containers
tl container build -n chef-client              # only build the chef-client container
tl container build -n chef-server,chef-client  # build the chef-server and chef-client container (NOTE: list order dictates execution order)
tl container build -n \!chef-server            # build all containers, except the chef-server container
</code></pre>

<h1>Installation</h1>

<ul>
<li>Install the latest version of VirtualBox: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></li>
<li>Install the latest version of Vagrant: <a href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a></li>
<li>Install the latest version of RVM: <a href="https://rvm.io/rvm/install">https://rvm.io/rvm/install</a></li>
</ul>

<h1>Updating</h1>

<ul>
<li>Install the latest version of VirtualBox: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></li>
<li>Install the latest version of Vagrant: <a href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a></li>
</ul>

<h1>Lab</h1>

<h2>Labfile</h2>

<p>The <code>Labfile</code> defines your virtual computer lab.  It defines where you want to run your computer lab (i.e. VirtualBox/OpenStack/Bare Metal), what the network topology of that computer lab is and what servers are connect to those networks.</p>

<p>You can override the default <code>Labfile</code> by setting the path to your alternate <code>Labfile</code> via the environment variable <code>LABFILE</code> or via a command line argument (see <code>tl help</code> for more details) directly to TestLab.</p>

<p>For some examples of Labfiles check out:</p>

<ul>
<li><a href="https://github.com/zpatten/testlab-repo">https://github.com/zpatten/testlab-repo</a></li>
</ul>

<h2>Building your Lab</h2>

<p>You should build your TestLab node (i.e. VirtualBox VM) and TestLab networks first.  This is the foundation which the containers run on.  You should attempt to keep your TestLab node intact and only cycle your containers.</p>

<p><strong>The follow commands assume you have functioning VirtualBox, Vagrant and RVM installations.</strong></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_build'>build</span>
</code></pre>

<h2>Demolishing your Lab</h2>

<p>You should demolish your TestLab node gracefully if possible.  This can be easily accomplished.</p>

<p><strong>The follow commands assume you have functioning VirtualBox, Vagrant and RVM installations.</strong></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tl'>tl</span> <span class='id identifier rubyid_demolish'>demolish</span>
</code></pre>

<h2>Importing Labs</h2>

<p>Importing entire labs with an embedded <code>Labfile</code> is coming soon.</p>

<h2>Containers</h2>

<h3>Building Containers</h3>

<p>You should import containers because it saves a lot of time.  Building containers from scratch is a time consuming process.  Using shipping container images and ultimately lab images greatly accelerates the speed at which you can move.</p>

<pre class="code ruby"><code class="ruby">tl container build --force                 # Force all defined containers to build even if some can be imported
tl container build                         # Attempts to import all defined containers, building those which can not be imported
tl container build -n chef-client --force  # Force the 'chef-client' container to build from scratch even if it can be imported
tl container build -n \!chef-server        # Build all containers, except the 'chef-server' container
</code></pre>

<h3>Importing Containers</h3>

<p>You should import containers because it saves a lot of time.  Building containers from scratch is a time consuming process.  Using shipping container images and ultimately lab images greatly accelerates the speed at which you can move.</p>

<pre class="code ruby"><code class="ruby">tl container import                             # Import all defined containers
tl container import -n chef-client              # Import the 'chef-client' container
tl container import -n chef-server,chef-client  # Import the 'chef-server' and 'chef-client' container
tl container import -n \!chef-server            # Import all containers, except the 'chef-server' container
</code></pre>

<h3>Demolishing Containers</h3>

<p>You can easily remove all the containers your have defined in your <code>Labfile</code> as well as single containers.  You should generally demolish your containers instead of destroying them because the demolish action involves decommissioning.</p>

<pre class="code ruby"><code class="ruby">tl container demolish                             # Demolish all defined containers
tl container demolish -n chef-client              # Only demolish the 'chef-client' container
tl container demolish -n chef-client,chef-server  # Only demolish the 'chef-client' and 'chef-server' containers
tl container demolish -n \!chef-server            # Demolish all containers, except the 'chef-server' container
</code></pre>

<h3>Recycle Containers</h3>

<p>You can demolish and build containers all in one motion by recycling them. If a container can be imported, recycle will attempt to do so during the build phase unless the force options is specified.</p>

<pre class="code ruby"><code class="ruby">tl container recycle                             # Recycle all defined containers
tl container recycle -n chef-client              # Only recycle the 'chef-client' container
tl container recycle -n chef-client --force      # Only recycle the 'chef-client' container and force building; do not import
tl container recycle -n chef-client,chef-server  # Only recycle the 'chef-client' and 'chef-server' containers
tl container recycle -n \!chef-server            # Recycle all containers, except the 'chef-server' container
</code></pre>

<h3>Bounce Containers</h3>

<p>You can easily restart (i.e. bounce) your containers, for example:</p>

<pre class="code ruby"><code class="ruby">tl container bounce                             # Bounce all defined containers
tl container bounce -n chef-client              # Only bounce the 'chef-client' container
tl container bounce -n chef-client,chef-server  # Only bounce the 'chef-client' and 'chef-server' containers
tl container bounce -n \!chef-server            # Bounce all containers, except the 'chef-server' container
</code></pre>

<h3>Start Containers</h3>

<p>You can easily start your containers, for example:</p>

<pre class="code ruby"><code class="ruby">tl container up                             # Start all defined containers
tl container up -n chef-client              # Only start the 'chef-client' container
tl container up -n chef-client,chef-server  # Only start the 'chef-client' and 'chef-server' containers
tl container up -n \!chef-server            # Start all containers, except the 'chef-server' container
</code></pre>

<h3>Stop Containers</h3>

<p>You can easily stop your containers, for example:</p>

<pre class="code ruby"><code class="ruby">tl container down                             # Stop all defined containers
tl container down -n chef-client              # Only stop the 'chef-client' container
tl container down -n chef-client,chef-server  # Only stop the 'chef-client' and 'chef-server' containers
tl container down -n \!chef-server            # Stop all containers, except the 'chef-server' container
</code></pre>

<h3>Container Status</h3>

<p>You can get the status of all, some or a single container, for example (-q silences all of the STDOUT log output):</p>

<pre class="code ruby"><code class="ruby">tl -q container status                             # Get status for all defined containers
tl -q container status -n chef-client              # Get status only for the 'chef-client' container
tl -q container status -n chef-client,chef-server  # Get status only for the 'chef-client' and 'chef-server' containers
tl -q container status -n \!chef-server            # Get the status of all containers, except the 'chef-server' container
</code></pre>

<h3>Connecting to Containers</h3>

<p><strong>The follow commands assume you have a functioning TestLab node with running containers.</strong></p>

<h4>Console</h4>

<p>You can easily open an LXC console to a container.  This would be similar to what you get when using IPMI to get a console.</p>

<pre class="code ruby"><code class="ruby">tl container console -n chef-client
</code></pre>

<h4>SSH</h4>

<p>You can easily open an SSH console to a container.  Simply use the SSH command and supply the name of the container you wish to connect to, in this example we are SSH&#39;ing to the chef-client container.</p>

<pre class="code ruby"><code class="ruby">tl container ssh -n chef-client
</code></pre>

<h4>TCP/UDP/ICMP</h4>

<p>You can easily use any type of IP based network communication to talk to your containers.  Your container names will resolve for all containers and for your local machine.  For example if you had a web server running on a container called www-app you could direct your web browser at &#39;<a href="http://www-app">http://www-app</a>&#39; to connect to it.</p>

<p>If you have a container named chef-client and you want to ping it, simply run ping against the host; for example:</p>

<pre class="code ruby"><code class="ruby">$ ping -c 5 chef-client
PING chef-client (100.64.13.253) 56(84) bytes of data.
64 bytes from chef-client (100.64.13.253): icmp_req=1 ttl=63 time=0.463 ms
64 bytes from chef-client (100.64.13.253): icmp_req=2 ttl=63 time=0.472 ms
64 bytes from chef-client (100.64.13.253): icmp_req=3 ttl=63 time=0.483 ms
64 bytes from chef-client (100.64.13.253): icmp_req=4 ttl=63 time=0.493 ms
64 bytes from chef-client (100.64.13.253): icmp_req=5 ttl=63 time=0.492 ms
--- chef-client ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 3999ms
rtt min/avg/max/mdev = 0.463/0.480/0.493/0.026 ms
</code></pre>

<p>If you have a container named chef-server and you want to NMAP scan it, simply run nmap against the host; for example:</p>

<pre class="code ruby"><code class="ruby">$ nmap -sT -vv chef-server
Starting Nmap 5.21 ( http://nmap.org ) at 2014-01-30 17:18 PST
Initiating Ping Scan at 17:18
Scanning chef-server (100.64.13.1) [2 ports]
Completed Ping Scan at 17:18, 0.00s elapsed (1 total hosts)
Initiating Connect Scan at 17:18
Scanning chef-server (100.64.13.1) [1000 ports]
Discovered open port 80/tcp on 100.64.13.1
Discovered open port 22/tcp on 100.64.13.1
Discovered open port 443/tcp on 100.64.13.1
Discovered open port 444/tcp on 100.64.13.1
Discovered open port 4000/tcp on 100.64.13.1
Completed Connect Scan at 17:18, 0.06s elapsed (1000 total ports)
Nmap scan report for chef-server (100.64.13.1)
Host is up (0.0029s latency).
Scanned at 2014-01-30 17:18:14 PST for 0s
Not shown: 995 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
443/tcp  open  https
444/tcp  open  snpp
4000/tcp open  remoteanything
Read data files from: /usr/share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.10 seconds
</code></pre>

<h3>Ephemeral Container Cloning</h3>

<p>As it stands attempting to iterate infrastructure with Vagrant is a slow and painful process.  Enter LXC and ephemeral cloning.  The idea here is that you have a container that is provisioned to a &quot;pristine&quot; state according to the <code>Labfile</code>.  You then clone this container and run actions against the container.  After running your actions against the container you want to maybe tweak your Chef cookbook, for example, and re-run it against the container.  Running an ever changing cookbook in development against the same system over and over again causes drift and problems.  With the cloning you can instantly reinstate the container as it was when you first cloned it.</p>

<p>In order to use the ephemeral cloning in LXC, we first need to put our container or containers into an ephemeral mode.  This allows TestLab to do certain operations on the backend to prepare the container for ephemeral cloning.  Then when you are finished, you can easily return the container to a persistent mode.</p>

<p>For example, to put the container into the ephemeral mode:</p>

<pre class="code ruby"><code class="ruby">$ tl container ephemeral -n chef-client
[TL] TestLab v1.1.0 Loaded
[TL] container chef-client ephemeral                         # Completed in 17.3453 seconds!
[TL] TestLab v1.1.0 Finished (17.8546 seconds)
</code></pre>

<p>Now with our container in the ephemeral mode, we can run all of the normal container tasks against it with one simple caveat.  When you offline the container and bring it back online, it will be reverted to the original state it was in before you put it into the ephemeral mode.  The short of all this is, you can do what you will to the container, but the moment you bounce it (offline then online it) it reverts.  This, as you can imagine, is extremely useful for developing applications and infrastructure as code.</p>

<p>You can quickly revert that chef node back to it&#39;s previous state in the event the cookbook you are developing has wrecked the node.  For web developers, imagine having a mysql server running in an ephemeral container; you can quickly roll back all database operations just by bouncing the container.</p>

<p>This is effectively transactions for infrastructure.</p>

<p>To put the container back into the default, persistent mode:</p>

<pre class="code ruby"><code class="ruby">$ tl container persistent -n chef-client
[TL] TestLab v1.1.0 Loaded
[TL] container chef-client persistent                        # Completed in 17.3692 seconds!
[TL] TestLab v1.1.0 Finished (17.8692 seconds)
</code></pre>

<h2>Network Routes</h2>

<p>TestLab will add network routes for any networks defined in the <code>Labfile</code> witch have the <code>TestLab::Provisioner::Route</code> provisioner class specified for them.  This will allow you to directly interact with containers over the network.  Here is an example of the routes added with the multi-network <code>Labfile</code>.</p>

<pre class="code ruby"><code class="ruby">$ tl network route show
[TL] TestLab v1.1.0 Loaded
TestLab routes:
172.16.0.0      192.168.33.2    255.255.255.0   UG        0 0          0 vboxnet0
[TL] TestLab v1.1.0 Finished (0.5063 seconds)
</code></pre>

<p>These routes can be manually manipulated as well (regardless of if you have specified the <code>TestLab::Provisioner::Route</code> provisioner class for the networks via the <code>Labfile</code>):</p>

<pre class="code ruby"><code class="ruby">$ tl help network route
NAME
    route - Manage routes

SYNOPSIS
    tl [global options] network route  add
    tl [global options] network route  del
    tl [global options] network route  show

COMMANDS
    add  - Add routes to lab networks
    del  - Delete routes to lab networks
    show - Show routes to lab networks
</code></pre>

<h1>Reference</h1>

<h2>APT-Cacher NG</h2>

<p>If you are prompted for login credentials while using the APT-Cacher NG web UI you should use username admin, password admin .</p>

<p>If you start seeing APT errors in your containers, it is likely because you have some corruption or some other issue with APT-Cacher NG&#39;s cache.  Access the URL below if you need to have APT-Cacher NG repair itself.</p>

<pre class="code ruby"><code class="ruby">http://100.64.13.254:3142/acng-report.html
</code></pre>

<h2>Chef-Server Web UI</h2>

<p>You can access the Chef server&#39;s web UI using the following URL.</p>

<pre class="code ruby"><code class="ruby">https://chef-server:444
</code></pre>

<h2>Chef-Server API</h2>

<p>You can access the Chef server&#39;s API using the following URL.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_https'>https</span><span class='symbol'>:/</span><span class='op'>/</span><span class='id identifier rubyid_chef'>chef</span><span class='op'>-</span><span class='id identifier rubyid_server'>server</span>
</code></pre>

<h2>Linux Containers (LXC)</h2>

<h3>Service Startup Delay</h3>

<p>LXC takes around 1-2 minutes before it will switch the runlevel in your container and start executing daemons which are set to start on boot. Because of this if you import a container from an image or clone a container, upon starting that container you will experience this delay before services are automatically started up. There is one exception to this and that is the SSH daemon is started immediately by LXC. This means you can manually SSH in, or use some other method such as capistrano, to start your required services; but it is advisable that you wait and allow the system to start the services as this would indicate that it would properly startup in production.  With some containers such as the chef-server; we use it&#39;s provisioner to start the services we want when TestLab brings the container online.</p>

<h1>Using TestLab Programmatically</h1>

<p>Accessing TestLab via code is meant to be fairly easy and straightforward.  To get an instance of TestLab you only need about four lines of code:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_log_file'>log_file</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='const'>Dir</span><span class='period'>.</span><span class='id identifier rubyid_pwd'>pwd</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>testlab.log</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
<span class='ivar'>@logger</span> <span class='op'>=</span> <span class='const'>ZTK</span><span class='op'>::</span><span class='const'>Logger</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_log_file'>log_file</span><span class='rparen'>)</span>
<span class='ivar'>@ui</span> <span class='op'>=</span> <span class='const'>ZTK</span><span class='op'>::</span><span class='const'>UI</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:logger</span> <span class='op'>=&gt;</span> <span class='ivar'>@logger</span><span class='rparen'>)</span>
<span class='ivar'>@testlab</span> <span class='op'>=</span> <span class='const'>TestLab</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:ui</span> <span class='op'>=&gt;</span> <span class='ivar'>@ui</span><span class='rparen'>)</span>
</code></pre>

<p>Calling <code>TestLab.new</code> without a <code>:labfile</code> option will, by default, attempt to read <code>Labfile</code> from the current directory.  This behavior can be changed by passing the <code>:labfile</code> key with a path to your desired &quot;Labfile&quot; as the value to your <code>TestLab.new</code>.</p>

<p>There are several easy accessors available to grab the first container and execute the command <code>uptime</code> on it via and SSH connection:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_container'>container</span> <span class='op'>=</span> <span class='ivar'>@testlab</span><span class='period'>.</span><span class='id identifier rubyid_containers'>containers</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_container'>container</span><span class='period'>.</span><span class='id identifier rubyid_exec'>exec</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>%(</span><span class='tstring_content'>uptime</span><span class='tstring_end'>)</span></span><span class='rparen'>)</span>
</code></pre>

<p>We can also execute this command via <code>lxc-attach</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_container'>container</span><span class='period'>.</span><span class='id identifier rubyid_lxc'>lxc</span><span class='period'>.</span><span class='id identifier rubyid_attach'>attach</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>%(</span><span class='tstring_content'>-- uptime</span><span class='tstring_end'>)</span></span><span class='rparen'>)</span>
</code></pre>

<p>You can access all the nodes for example:</p>

<pre class="code ruby"><code class="ruby"><span class='ivar'>@testlab</span><span class='period'>.</span><span class='id identifier rubyid_nodes'>nodes</span>
</code></pre>

<p>For more information see the TestLab Documentation, <code>testlab-repo</code>, command-line binary and it never hurts to look at the TestLab source itself.</p>

<p>You can also check out the <code>tl-knife</code> command-line binary for another example of using TestLab in a programmatic fashion:</p>

<ul>
<li><a href="https://github.com/zpatten/testlab/blob/master/bin/tl-knife">https://github.com/zpatten/testlab/blob/master/bin/tl-knife</a></li>
</ul>

<h1>REQUIREMENTS</h1>

<ul>
<li>Latest VirtualBox Package</li>
<li>Latest Vagrant Package (non-gem version)</li>
<li><p>Ubuntu 13.04 Base Box Recommended</p></li>
<li><p>Ubuntu 13.04 Server 64-bit (Raring) Base Box - <a href="https://github.com/zpatten/raring64">https://github.com/zpatten/raring64</a></p></li>
</ul>

<h1>EXAMPLE USE</h1>

<ul>
<li>See the <code>testlab-repo</code> - <a href="https://github.com/lookout/testlab-repo">https://github.com/lookout/testlab-repo</a></li>
</ul>

<h1>RUBIES TESTED AGAINST</h1>

<ul>
<li>Ruby 1.8.7 (REE)</li>
<li>Ruby 1.8.7 (MBARI)</li>
<li>Ruby 1.9.2</li>
<li>Ruby 1.9.3</li>
<li>Ruby 2.0.0</li>
</ul>

<h1>RESOURCES</h1>

<p>IRC:</p>

<ul>
<li>#jovelabs on irc.freenode.net</li>
</ul>

<p>Documentation:</p>

<ul>
<li><a href="http://lookout.github.io/testlab/">http://lookout.github.io/testlab/</a></li>
</ul>

<p>Source:</p>

<ul>
<li><a href="https://github.com/lookout/testlab">https://github.com/lookout/testlab</a></li>
</ul>

<p>Issues:</p>

<ul>
<li><a href="https://github.com/lookout/testlab/issues">https://github.com/lookout/testlab/issues</a></li>
</ul>

<h1>LICENSE</h1>

<p>TestLab - A framework for building lightweight virtual laboratories using LXC</p>

<ul>
<li>Author: Zachary Patten <zachary AT jovelabs DOT com> <a href="http://coderwall.com/zpatten"><img src="http://api.coderwall.com/zpatten/endorsecount.png" alt="endorse"></a></li>
<li>Copyright: Copyright (c) Zachary Patten</li>
<li>License: Apache License, Version 2.0</li>
</ul>

<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_http'>http</span><span class='symbol'>:/</span><span class='op'>/</span><span class='id identifier rubyid_www'>www</span><span class='period'>.</span><span class='id identifier rubyid_apache'>apache</span><span class='period'>.</span><span class='id identifier rubyid_org'>org</span><span class='op'>/</span><span class='id identifier rubyid_licenses'>licenses</span><span class='op'>/</span><span class='const'>LICENSE</span><span class='op'>-</span><span class='float'>2.0</span>
</code></pre>

<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
</div></div>

    <div id="footer">
  Generated on Tue Mar 25 11:29:19 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.3 (ruby-1.9.3).
</div>

  </body>
</html>